## 데이터 분석 예제 (2)

### 신생아 이름

- 1880년부터 현재까지 가장 빈도가 높은 신생아 이름에 대한 데이터

```python
years = range(1880, 2011)

pieces = []
columns = ["name", "sex", "births"]

for year in years:
    path = "datasets/babynames/yob{}.txt".format(year)
    frame = pd.read_csv(path, names=columns)
    
    frame["year"] = year
    pieces.append(frame)
    
names = pd.concat(pieces, ignore_index=True)
names
```

- 1880 ~ 2011년 까지의 데이터를 하나로 병합

<img src="https://user-images.githubusercontent.com/58063806/123973361-a9453780-d9f6-11eb-80c2-481ca20ef4b0.png" width=25% />

```python
total_births = names.pivot_table("births", index="year", columns="sex", aggfunc=sum)
total_births.plot(title="Total births by sex and year")
```

- 각 연도와 성별에 따른 출생수의 추이

<img src="https://user-images.githubusercontent.com/58063806/123973807-0d67fb80-d9f7-11eb-8e68-584eb086cb88.png" width=50% />

```python
names["prop"] = names.births / names.groupby(["year", "sex"]).births.transform("sum")
names

# 모든 그룹에서 prop 컬럼의 합이 1이 되는지 확인
# names.groupby(["year", "sex"]).prop.sum()
```

- 각 연도와 성별에 따라 각 이름이 차지하는 비율을 추가

<img src="https://user-images.githubusercontent.com/58063806/123974774-db0ace00-d9f7-11eb-9c25-34daf0322e65.png" width=30% />

```python
pieces = []
for year, group in names.groupby(["year", "sex"]):
    pieces.append(group.sort_values(by="births", ascending=False)[:1000])
top1000 = pd.concat(pieces, ignore_index=True)
top1000
```

- 각 그룹에서 상위 1000개에 해당하는 이름만 추출

<img src="https://user-images.githubusercontent.com/58063806/123975908-aea38180-d9f8-11eb-91a9-6c7c1a2eb8d6.png" width=30% />

```python
total_births = top1000.pivot_table("births", index="year", columns="name", aggfunc=sum)
subset = total_births[["John", "Harry", "Mary", "Marilyn"]]
subset.plot(subplots=True, figsize=(12, 10), grid=False, title="Number of births per year")
```

- 일부 이름에 대한 연도별 추이
- 최근으로 올수록 전체적으로 각 이름들의 발생빈도가 줄어듬 (흔한 이름을 기피하는 경향)

<img src="https://user-images.githubusercontent.com/58063806/123976174-e7435b00-d9f8-11eb-9d31-b3d8dfe252d4.png" width=70%/>

```python
table = top1000.pivot_table("prop", index="year", columns="sex", aggfunc=sum)
table.plot(title="Sum of table1000.prop by year and sex", 
           yticks=np.linspace(0, 1.2, 13), xticks=range(1880, 2020, 10))
```

- 각 연도에서 상위 1000개의 이름들이 차지하는 비율 추이
- 점점 비율이 떨어지는 것으로 볼 때 최근으로 올수록 흔한 이름들을 적게 사용하고 다양한 이름들을 사용한다는 것을 알 수 있음

<img src="https://user-images.githubusercontent.com/58063806/123977505-01316d80-d9fa-11eb-8d95-fc809c77297b.png" width=50%/>

```python
def get_quantile_count(group, q=0.5):
    group = group.sort_values(by="prop", ascending=False)
    return group.prop.cumsum().values.searchsorted(q) + 1

diversity = top1000.groupby(["year", "sex"]).apply(get_quantile_count)
diversity = diversity.unstack("sex")
diversity.head()
```

- 각 이름이 차지하는 비율을 기준으로 내림차순 정렬 후 전체의 50%가 되기 까지 몇개의 이름이 등장하는지 체크
- searchsorted : 정렬된 상태에서 누계가 q가 되는 위치(index)를 구함

<img src="https://user-images.githubusercontent.com/58063806/123978543-e90e1e00-d9fa-11eb-81f5-c34a9ca9dcb7.png" width=13%>

```python
diversity.plot(title="Number of popular names in top 50%")
```

- 각 연도별로 이름들이 차지하는 비율의 누계가 50%가 될 때까지의 이름 갯수
- 최근으로 올수록 누계가 50%가 될 때까지의 이름 갯수가 많아지는 것을 볼 수 있음
  - 점점 다양한 이름을 사용하는 것을 알 수 있음

<img src="https://user-images.githubusercontent.com/58063806/123978872-2e325000-d9fb-11eb-99a1-647baea2e4f6.png" width=50% />