## 데이터 정제 및 준비

#### 개별화와 양자화

- 연속성 데이터는 종종 개별로 분할하거나 분석을 위해 그룹별로 나눔

```python
import pandas as pd

ages = [20, 22, 25, 27, 21, 23, 37, 31, 61, 45, 41, 32]
bins = [18, 25, 35, 60, 100]

cats = pd.cut(ages, bins)

# [(18, 25], (18, 25], (18, 25], (25, 35], (18, 25], ..., (25, 35], (60, 100], (35, 60], (35, 60], (25, 35]]
# Length: 12
# Categories (4, interval[int64]): [(18, 25] < (25, 35] < (35, 60] < (60, 100]]
```

- Categorical이라는 특수한 객체를 반환

```python
cats.codes
# array([0, 0, 0, 1, 0, 0, 2, 1, 3, 2, 2, 1], dtype=int8)
```

- ages 데이터에 대한 카테고리 인덱스

```python
cats.categories
# IntervalIndex([(18, 25], (25, 35], (35, 60], (60, 100]], closed='right', dtype='interval[int64]')
```

- codes 속성에 있는 ages 데이터에 대한 카테고리 이름
- 간격을 나타내는 표기는 중괄호로 시작해서 대괄호로 끝나는데 **중괄호 쪽의 값은 포함하지 않고 대괄호 쪽의 값은 포함**

```python
pd.cut(ages, [18, 26, 36, 61, 100], right=False)

# [[18, 26), [18, 26), [18, 26), [26, 36), [18, 26), ..., [26, 36), [61, 100), [36, 61), [36, 61), [26, 36)]
# Length: 12
# Categories (4, interval[int64]): [[18, 26) < [26, 36) < [36, 61) < [61, 100)]

group_names = ["Youth", "YoungAdult", "MiddleAged", "Senior"]

pd.cut(ages, bins, labels=group_names)

# [Youth, Youth, Youth, YoungAdult, Youth, ..., YoungAdult, Senior, MiddleAged, MiddleAged, YoungAdult]
# Length: 12
# Categories (4, object): [Youth < YoungAdult < MiddleAged < Senior]
```

- right=False 옵션으로 중괄호와 대괄호의 위치를 바꿀 수 있음

- labels 옵션으로 그룹의 이름을 직접지정 가능

```python
import numpy as np

data = np.random.rand(20)
# precision - 소수점 자리수
pd.cut(data, 4, precision=2)

# [(0.75, 0.99], (0.52, 0.75], (0.29, 0.52], (0.52, 0.75], (0.75, 0.99], ..., (0.06, 0.29], (0.06, 0.29], (0.75, 0.99], (0.29, 0.52], (0.29, 0.52]]
# Length: 20
# Categories (4, interval[float64]): [(0.06, 0.29] < (0.29, 0.52] < (0.52, 0.75] < (0.75, 0.99]]
```

- 그룹의 경계값을 넘기지 않고 그룹의 개수를 넘겨주면 데이터에서 최솟값과 최댓값을 기준으로 균등한 길이의 그룹을 자동으로 계산 

```python
data = np.random.randn(1000)

# 4분위로 분할
cats = pd.qcut(data, 4)

# [(-3.455, -0.704], (0.707, 3.526], (-0.704, 0.0376], (-3.455, -0.704], (0.0376, 0.707], ..., (0.707, 3.526], (0.707, 3.526], (-0.704, 0.0376], (0.0376, 0.707], (0.0376, 0.707]]
# Length: 1000
# Categories (4, interval[float64]): [(-3.455, -0.704] < (-0.704, 0.0376] < (0.0376, 0.707] < (0.707, 3.526]]

cats.value_counts()

# (-3.455, -0.704]    250
# (-0.704, 0.0376]    250
# (0.0376, 0.707]     250
# (0.707, 3.526]      250
```

- cut 함수를 사용하면 **데이터의 분산에 따라 각각의 그룹마다 데이터의 수가 다르게 나뉘는 경우가 많음**
- qcut은 **표준 변위치를 기반으로 데이터를 분할하기 때문에 적당히 같은 크기의 그룹으로 나눌 수 있음**

```python
pd.qcut(data, [0, 0.1, 0.5, 0.9, 1.])

# [(-3.455, -1.288], (1.276, 3.526], (-1.288, 0.0376], (-1.288, 0.0376], (0.0376, 1.276], ..., (1.276, 3.526], (0.0376, 1.276], (-1.288, 0.0376], (0.0376, 1.276], (0.0376, 1.276]]
# Length: 1000
# Categories (4, interval[float64]): [(-3.455, -1.288] < (-1.288, 0.0376] < (0.0376, 1.276] < (1.276, 3.526]]
```

- cut 함수와 유사하게 변위치(0 ~ 1)를 직접 지정 가능