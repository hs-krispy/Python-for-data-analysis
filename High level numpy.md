### High level numpy

#### 정렬

- 하나 이상의 키를 기준으로 데이터를 정렬하는 상황이 많음 
  - EX) A로 정렬한 다음 B로 정렬 (간접 정렬)

**argsort**

```python
import numpy as np

arr = np.random.randn(3, 5)
arr
# array([[ 1.19150081, -1.39283864, -0.65707704, -0.62087326, -2.04337546],
#        [ 1.78060301, -2.08695138, -0.07934292,  0.4884494 , -0.21521199],
#        [ 0.33917024, -1.96489678, -0.41936347,  0.16890563, -0.74344259]])


# 첫 번째 로우을 기준으로 나머지 로우도 다 같이 정렬
arr2 = arr[:, arr[0].argsort()]
# array([[-2.04337546, -1.39283864, -0.65707704, -0.62087326,  1.19150081],
#        [-0.21521199, -2.08695138, -0.07934292,  0.4884494 ,  1.78060301],
#        [-0.74344259, -1.96489678, -0.41936347,  0.16890563,  0.33917024]])

# 위의 결과를 역순으로 
arr2[:, ::-1]
# array([[ 1.19150081, -0.62087326, -0.65707704, -1.39283864, -2.04337546],
#        [ 1.78060301,  0.4884494 , -0.07934292, -2.08695138, -0.21521199],
#        [ 0.33917024,  0.16890563, -0.41936347, -1.96489678, -0.74344259]])
```

**lexsort**

```python
first_name = np.array(["Bob", "Jane", "Steve", "Bill", "Barbara"])
last_name = np.array(["Jones", "Arnold", "Arnold", "Jones", "Walters"])

sorter = np.lexsort([first_name, last_name])
sorter
# array([1, 2, 3, 0, 4], dtype=int64)

last_name[sorter], first_name[sorter]
# (array(['Arnold', 'Arnold', 'Jones', 'Jones', 'Walters'], dtype='<U7'),
#  array(['Jane', 'Steve', 'Bill', 'Bob', 'Barbara'], dtype='<U7'))
```

- lexsort는 나중에 넘겨준 배열을 우선적으로 정렬을 수행
  - last name으로 정렬 후 동일한 결과에 대해서 first_name으로 정렬

**partition**

```python
np.random.seed(12345)
arr = np.random.randn(20)
arr
# array([-0.20470766,  0.47894334, -0.51943872, -0.5557303 ,  1.96578057,
#         1.39340583,  0.09290788,  0.28174615,  0.76902257,  1.24643474,
#         1.00718936, -1.29622111,  0.27499163,  0.22891288,  1.35291684,
#         0.88642934, -2.00163731, -0.37184254,  1.66902531, -0.43856974])

# 반환된 결과의 첫 세 원소는 해당 배열에서 가장 작은 값
np.partition(arr, 3)
# array([-2.00163731, -1.29622111, -0.5557303 , -0.51943872, -0.37184254,
#        -0.43856974, -0.20470766,  0.28174615,  0.76902257,  0.47894334,
#         1.00718936,  0.09290788,  0.27499163,  0.22891288,  1.35291684,
#         0.88642934,  1.39340583,  1.96578057,  1.66902531,  1.24643474])

# argsort와 유사하게 해당 원소의 위치를 반환
np.argpartition(arr, 3)
# array([16, 11,  3,  2, 17, 19,  0,  7,  8,  1, 10,  6, 12, 13, 14, 15,  5,
#        4, 18,  9], dtype=int64)
```

- partition은 정렬을 하는 배열의 가장 작은 n개의 원소가 반환 결과의 앞에 오도록 정렬