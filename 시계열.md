## 시계열

#### datetime

```python
from datetime import datetime

now = datetime.now()
now
# datetime.datetime(2021, 5, 29, 22, 57, 8, 521827)
# 연, 월, 일, 시, 분, 초, 마이크로초까지 지원

delta = datetime(2011, 1, 7) - datetime(2008, 6, 24, 8, 15)
delta
# datetime.timedelta(days=926, seconds=56700)
# 일, 초, 마이크로초 지원
```

- timedelta는 datetime 객체 간의 시간차이를 표현

```python
from datetime import timedelta

start = datetime(2011, 1, 7)
start + timedelta(12)
# datetime.datetime(2011, 1, 19, 0, 0)
start - 2 * timedelta(12)
# datetime.datetime(2010, 12, 14, 0, 0)
```

- timedelta를 datetime 객체에 더하거나 빼는 것도 가능

```python
stamp = datetime(2011, 1, 3)

str(stamp)
# '2011-01-03 00:00:00'
stamp.strftime("%Y-%m-%d")
# '2011-01-03'

datestrs = ['7/6/2011', '8/6/2011']
[datetime.strptime(x, "%m/%d/%Y") for x in datestrs]
# [datetime.datetime(2011, 7, 6, 0, 0), datetime.datetime(2011, 8, 6, 0, 0)]
```

- str, strftime으로 datetime을 문자열로 변환
- strptime으로 문자열을 datetime으로 변환

```python
from dateutil.parser import parse

parse("2011-01-03")
# datetime.datetime(2011, 1, 3, 0, 0)

parse("Jan 31, 1997 10:45 PM")
# datetime.datetime(1997, 1, 31, 22, 45)

# 날짜가 맨 앞에 오는 경우
parse('6/12/2011', dayfirst=True)
# datetime.datetime(2011, 12, 6, 0, 0)
```

- dateutil.parse를 이용해서 매번 포맷 규칙을 쓰지 않고 쉽게 문자열을 datetime으로 변환

```python
import pandas as pd

datestrs = ["2011-07-06 12:00:00", "2011-08-06 00:00:00"]
pd.to_datetime(datestrs)
# DatetimeIndex(['2011-07-06 12:00:00', '2011-08-06 00:00:00'], dtype='datetime64[ns]', freq=None)

idx = pd.to_datetime(datestrs + [None])
idx
# DatetimeIndex(['2011-07-06 12:00:00', '2011-08-06 00:00:00', 'NaT'], dtype='datetime64[ns]', freq=None)
```

- to_datetime은 표준 날짜 형식을 매우 빠르게 처리하고 누락된 값도 NaT로 처리

#### 시계열 기초

```python
dates = [datetime(2011, 1, 2), datetime(2011, 1, 5),
        datetime(2011, 1, 7), datetime(2011, 1, 8),
        datetime(2011, 1, 10), datetime(2011, 1, 12)]

# datetime객체들이 DatetimeIndex에 들어있는 시계열 데이터
ts = pd.Series(np.random.randn(6), index=dates)
ts
# 2011-01-02   -0.577712
# 2011-01-05   -1.231654
# 2011-01-07    1.747853
# 2011-01-08   -1.681626
# 2011-01-10    0.750115
# 2011-01-12    0.908471

ts + ts[::2]
# 2011-01-02   -1.155424
# 2011-01-05         NaN
# 2011-01-07    3.495706
# 2011-01-08         NaN
# 2011-01-10    1.500230
# 2011-01-12         NaN

stamp = ts.index[0]
stamp
# Timestamp('2011-01-02 00:00:00')
```

- 서로 다르게 색인된 **시계열 객체 간의 산술 연산은 자동으로 날짜(index)에 맞춰짐**
- DatetimeIndex의 스칼라 값은 pandas의 Timestamp 객체
  - Timestamp 객체는 datetime객체를 사용하는 어떤 곳에도 대체 사용이 가능

```python
stamp = ts.index[-2]
ts[stamp]
ts['1/10/2011']
ts['20110110']
# 0.7501151099342338

ts[datetime(2011, 1, 7):]
# 2011-01-07    1.747853
# 2011-01-08   -1.681626
# 2011-01-10    0.750115
# 2011-01-12    0.908471

ts["1/6/2011":'1/11/2011']
# 2011-01-07    1.747853
# 2011-01-08   -1.681626
# 2011-01-10    0.750115
```

- 라벨에 기반해서 데이터를 인덱싱
- 대부분의 시계열 데이터는 연대순으로 정렬되기 때문에 **날짜 문자열이나 datetime 혹은 타임스탬프를 이용해서 원본 시계열에 대한 뷰를 생성** 
  - 이에 대한 변경이 원본 데이터에도 반영

```python
ts.truncate(after='1/9/2011')
# 2011-01-02   -0.577712
# 2011-01-05   -1.231654
# 2011-01-07    1.747853
# 2011-01-08   -1.681626
ts.truncate(before='1/9/2011')
# 2011-01-10    0.750115
# 2011-01-12    0.908471
```

- 특정 시점 이전이나 이후의 데이터 추출
  - after - 해당 시점이후의 데이터를 자름 (해당 시점 이전의 데이터만 추출)
  - before - 해당 시점 이전의 데이터를 자름 (해당 시점 이후의 데이터만 추출)

```python
longer_ts = pd.Series(np.random.randn(1000),
                     index=pd.date_range('1/1/2000', periods=1000))

longer_ts
# 2000-01-01    3.080519
# 2000-01-02    0.798148
# 2000-01-03    1.630200
# 2000-01-04    2.332720
# 2000-01-05   -0.168789
#                 ...   
# 2002-09-22    0.753469
# 2002-09-23   -1.224349
# 2002-09-24   -0.156449
# 2002-09-25    0.361287
# 2002-09-26   -2.217907

longer_ts['2001']
# 2001-01-01   -0.812100
# 2001-01-02   -0.178954
# 2001-01-03    1.768009
# 2001-01-04    0.942992
# 2001-01-05   -0.464456
#                 ...   
# 2001-12-27   -1.800393
# 2001-12-28   -1.373362
# 2001-12-29    0.344692
# 2001-12-30    1.399496
# 2001-12-31   -0.531002

# 월까지 넘긴 경우
# longer_ts['2001-05']
```

- 긴 시계열에서는 연, 월만 넘겨서 데이터의 일부 구간만 선택가능

